import os
import os.path
import PIL
import json
import numpy as np
from PIL import Image
from numpy import asarray
from nbtlib import parse_nbt
from bolt import Runtime
from beet.library.resource_pack import Texture, Language, Font
from bolt.contrib.defer import Defer
from bolt_expressions import Scoreboard, identifier_generator
import lib:global/scoreboard as scb
import lib:global/utils as utils

# Documentación:
# 
# 
# 


runtime = ctx.inject(Runtime)
defer = ctx.inject(Defer)
ASSETS_PATH = ctx.directory / f"rp/assets/mcgame"
CURRENT_PATH = ctx.directory / "src/data/lib/modules/gui"
NAMESPACE = f"mcgame:actionbar"



def _id_generator(input=None):
    i = 0
    while True:
        yield i
        i += 1


def _unicode_generator(input=None):
    i = 57344
    while True:
        if i == 63488:
            i = 63552
        out = chr(i)
        yield out
        i += 1


def _condition_image(image):
    image_vec = np.array(image)
    width = len(image_vec[0])

    padding = max(0, 65 - len(image_vec))
    image_vec = np.vstack((np.zeros((padding, width, 4), dtype=np.uint8), image_vec))

    if image_vec[0][0][3] == 0:
        image_vec[0][0][3] = 1
    if image_vec[0][width - 1][3] == 0:
        image_vec[0][width - 1][3] = 1

    return Image.fromarray(image_vec)


def _fill_horizontal_png(path_full, path_empty, start, end, steps):
    image_full = np.array(_condition_image(Image.open(path_full).convert("RGBA")))
    image_empty = np.array(_condition_image(Image.open(path_empty).convert("RGBA")))
    step_size = (end - start + 1) / (steps + 1)

    for step in range(steps + 1):
        image_out = image_full.copy()
        order = tuple(sorted((round(start + step * step_size), end)))
        
        image_out[:, order[0]:order[1]] = image_empty[:, order[0]:order[1]]

        yield Image.fromarray(image_out)


def _fill_vertical_png(path_full, path_empty, start, end, steps):
    image_full = np.array(_condition_image(Image.open(path_full).convert("RGBA")))
    image_empty = np.array(_condition_image(Image.open(path_empty).convert("RGBA")))
    step_size = (start - end + 1) / (steps + 1)

    for step in range(steps + 1):
        image_out = image_full.copy()
        order = tuple(sorted((round(end + step * step_size), start)))
        
        image_out[order[0]:order[1]] = image_empty[order[0]:order[1]]

        yield Image.fromarray(image_out)


class ActionbarElement:
    all_elements = set()

    def __init__(self, name):
        self.name = name
        self.res_x = None
        self.res_y = None
        self.possible_y = {}
        id = ctx.inject(_id_generator)
        self.id = next(id)
        ActionbarElement.all_elements.add(self)
    
    
    def disable(self, player):
        target = utils.selector(player)
        execute as target:
            for player_id in generate_tree(range(ctx.meta.config.actionbar.max_players)):
                append function player_id.parent:
                    if player_id.partition(4):
                        if score var Scoreboard("player_id")["@s"] matches player_id.range function player_id.children
                    else:
                        if score var Scoreboard("player_id")["@s"] matches player_id.value:
                            stored_text = f'None'
                            data modify storage NAMESPACE f"{player_id.value}[{self.id}]" set value stored_text
    
    def _get_id(self):
        return self.id


class UnicodeBar(ActionbarElement):
    all_elements = set()

    def __init__(self, source, max, name):
        ActionbarElement.__init__(self, name)
        self.source = source
        self.max = max
        UnicodeBar.all_elements.add(self)

    def generate_horizontal(self, start_pixel, end_pixel, steps, directory=""):
        self.fill = _fill_horizontal_png
        self.type = "generated"
        self.directory = ASSETS_PATH / directory
        self.image = PIL.Image.open(self.directory / (str(self.name) + "_full.png"))
#        try:
#            self.image = PIL.Image.open(self.directory / (str(self.name) + "_full.png"))
#        except:
#            raise Exception(f"Couldn't load file {ASSETS_PATH / directory / (str(self.name) + '_full.png'}")
        self.start_pixel = start_pixel
        self.end_pixel = end_pixel
        self.steps = steps
        self.res_x = self.image.size[0]
        self.res_y = max(self.image.size[1], 65)

    def generate_vertical(self, start_pixel, end_pixel, steps, directory=""):
        self.fill = _fill_vertical_png
        self.type = "generated"
        self.directory = ASSETS_PATH / directory
        self.image = PIL.Image.open(self.directory / (str(self.name) + "_full.png"))
        self.start_pixel = start_pixel
        self.end_pixel = end_pixel
        self.steps = steps
        self.res_x = self.image.size[0]
        self.res_y = max(self.image.size[1], 65)
    
    def premade_source(self, directory=""):
        self.type = "premade"
        self.directory = ASSETS_PATH / directory
        self.image_list = []
        for n in range(self.max + 1):
            self.image_list.append(PIL.Image.open(self.directory / (str(self.name) + "_"+ str(n) + ".png")))  # De vuelta el try-except
        
        self.res_x = self.image_list[0].size[0]
        self.res_y = max(self.image_list[0].size[1], 65)


    def update(self, player, position_x, position_y):  # Selector = jugador al que se actualiza
        # Agregar la posición y al conjunto de posibles posiciones y (léase "y" como variable).
        generate_entry = ctx.inject(_unicode_generator)
        self.possible_y[position_y] = []
        for i in range(self.max + 1):
            self.possible_y[position_y].append(next(generate_entry))

        # Calcular la posición x apropiada
        q = self.res_x % 2

        # Editar efectivamente el data storage
        target = utils.selector(player)
        _root = runtime.modules.current_path
        @defer
        def _position_bars():
            execute as target:
                for player_id in generate_tree(range(ctx.meta.config.actionbar.max_players), root=_root):
                    append function player_id.parent:
                        if player_id.partition(4):
                            if score var Scoreboard("player_id")["@s"] matches player_id.range function player_id.children
                        else:
                            if score var Scoreboard("player_id")["@s"] matches player_id.value:
                                for node in generate_tree(range(self.max + 1), root=_root):
                                    append function node.parent:
                                        if node.partition(4):
                                            if score var self.source matches node.range function node.children
                                        else:
                                            if score var self.source matches node.value:
                                                ordered_elements = sorted(ActionbarElement.all_elements, key=ActionbarElement._get_id)
                                                message_width = -1
                                                for elem in ordered_elements:
                                                    message_width += elem.res_x + 1

                                                current_position = (- message_width // 2)
                                                for elem in ordered_elements[:self.id]:
                                                    current_position += elem.res_x + 1

                                                stored_text = ''
                                                stored_text += f'['
                                                stored_text += f'    {{'[4:]
                                                stored_text += f'        "translate":"offset.{position_x-current_position}",'[8:]
                                                stored_text += f'        "with": ['[8:]
                                                stored_text += f'            {{'[12:]
                                                stored_text += f'                "text":"{self.possible_y[position_y][node.value]}",'[16:]
                                                stored_text += f'                "color":"#4e5c24"'[16:]
                                                stored_text += f'            }}'[12:]
                                                stored_text += f'        ]'[8:]
                                                stored_text += f'    }}'[4:]
                                                stored_text += f']'

                                                data modify storage NAMESPACE f"{player_id.value}[{self.id}]" set value stored_text


class UnicodeIcon(ActionbarElement):
    all_elements = set()

    def __init__(self, name, directory=""):
        ActionbarElement.__init__(self, name)
        UnicodeIcon.all_elements.add(self)

        self.image = PIL.Image.open(ASSETS_PATH / directory / (str(self.name) + ".png"))
        self.res_x = self.image.size[0]
        self.res_y = self.image.size[1]

    def enable(self, player, position_x, position_y):  # Selector = jugador al que se actualiza
        generate_entry = ctx.inject(_unicode_generator)
        self.possible_y[position_y] = next(generate_entry)

        q = 0
        if (self.res_x % 2) == 1:
            q = 1
        offset_x = position_x + (self.res_x // 2) + q

        target = utils.selector(player)
        execute as target:
            for player_id in generate_tree(range(ctx.meta.config.actionbar.max_players)):
                append function player_id.parent:
                    if player_id.partition(4):
                        if score var Scoreboard("player_id")["@s"] matches player_id.range function player_id.children
                    else:
                        if score var Scoreboard("player_id")["@s"] matches player_id.value:
                            stored_text = f'{{"translate":"offset.{offset_x}","with":[{{"text":"{self.possible_y[position_y]}","color":"#4e5c24"}}]}}'
                            data modify storage NAMESPACE f"{player_id.value}[{self.id}]" set value stored_text


def display(player):
    target = utils.selector(player)
    execute as target:
        for player_id in generate_tree(range(ctx.meta.config.actionbar.max_players)):
            append function player_id.parent:
                if player_id.partition(4):
                    if score var Scoreboard("player_id")["@s"] matches player_id.range function player_id.children
                else:
                    if score var Scoreboard("player_id")["@s"] matches player_id.value:
                        message = f'{{"storage":"{NAMESPACE}","nbt":"{player_id.value}[]","separator":"","interpret":true,"color":"#4e5c24"}}'
                        title @s actionbar json.loads(message)


# Construcción de las barras
init_function = utils.init_func()
@defer  # Es necesario poner esto para que se pueda leer bien la lista de todas las barras creadas después del Runtime.
def deferred_actionbars():
    if len(ActionbarElement.all_elements) != 0:
        empty_data = ""
        for i in range(ctx.meta.config.actionbar.max_players):
            empty_data += f'{i}:['
            for j in range(len(ActionbarElement.all_elements)):
                empty_data += f'{"None"},'
            empty_data = empty_data[0:-1]
            empty_data += f'],'
        empty_data = "{" + empty_data[0:-1] + "}"
        empty_data = parse_nbt(empty_data)
        
        function init_function:
            data merge storage NAMESPACE empty_data
        

        textures = ctx.assets.textures
        languages = ctx.assets.languages
        fonts = ctx.assets.fonts


        for element in UnicodeBar.all_elements:
            if element.type == "generated":
                sprites = element.fill(element.directory / (str(element.name) + "_full.png"),
                                       element.directory / (str(element.name) + "_empty.png"),
                                       element.start_pixel, element.end_pixel, element.max)
            else:
                def _iterator(list):
                    i = 0
                    while True:
                        yield _condition_image(list[i])
                        i += 1
                sprites = _iterator(element.image_list)

            for n in range(element.max + 1):
                font_namespace = f"mcgame:font/{element.name}_{n}"
                textures[font_namespace] = Texture(next(sprites))
            

            for height in element.possible_y:
                for amount, unicode_id in enumerate(element.possible_y[height]):
                    merge font minecraft:default {
                        "providers": [
                            {
                                "type": "bitmap",
                                "file": f"mcgame:font/{element.name}_{amount}.png",
                                "ascent": (height + max(element.res_y - 65, 0)),
                                "height": element.res_y,
                                "chars": [unicode_id]
                            }
                        ]
                    }

        for element in UnicodeIcon.all_elements:
            pass


        textures["space:font/space_nosplit"] = Texture(source_path = CURRENT_PATH / "private/actionbar/space_nosplit.png")
        textures["space:font/space_split"] = Texture(source_path = CURRENT_PATH / "private/actionbar/space_split.png")
        languages["space:en_us"] = Language(source_path = CURRENT_PATH / "private/actionbar/lang.json")
        fonts["space:default"] = Font(source_path = CURRENT_PATH / "private/actionbar/space_default.json")

